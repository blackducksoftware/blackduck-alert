/*
 * provider-blackduck
 *
 * Copyright (c) 2021 Synopsys, Inc.
 *
 * Use subject to the terms and conditions of the Synopsys End User Software License and Maintenance Agreement. All rights reserved worldwide.
 */
package com.synopsys.integration.alert.provider.blackduck.processor.message.service;

import java.math.BigDecimal;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;

import org.apache.commons.lang3.EnumUtils;
import org.springframework.stereotype.Component;

import com.synopsys.integration.alert.common.message.model.LinkableItem;
import com.synopsys.integration.alert.processor.api.extract.model.project.ComponentVulnerabilities;
import com.synopsys.integration.blackduck.api.generated.component.ProjectVersionComponentVersionVulnerabilityRemediationCvss2View;
import com.synopsys.integration.blackduck.api.generated.component.ProjectVersionComponentVersionVulnerabilityRemediationCvss3View;
import com.synopsys.integration.blackduck.api.generated.component.RiskProfileCountsView;
import com.synopsys.integration.blackduck.api.generated.enumeration.VulnerabilityRemediationStatusType;
import com.synopsys.integration.blackduck.api.generated.enumeration.VulnerabilitySeverityType;
import com.synopsys.integration.blackduck.api.generated.view.ProjectVersionComponentVersionView;
import com.synopsys.integration.blackduck.api.generated.view.RiskProfileView;
import com.synopsys.integration.rest.HttpUrl;

@Component
public class BlackDuckComponentVulnerabilityDetailsCreator {
    private static final String LABEL_VULNERABILITY = "Vulnerability";

    public ComponentVulnerabilities toComponentVulnerabilities(List<BlackDuckProjectVersionComponentVulnerabilitiesView> vulnerabilities) {
        List<LinkableItem> criticalVulns = new LinkedList<>();
        List<LinkableItem> highVulns = new LinkedList<>();
        List<LinkableItem> mediumVulns = new LinkedList<>();
        List<LinkableItem> lowVulns = new LinkedList<>();

        for (BlackDuckProjectVersionComponentVulnerabilitiesView vulnerability : vulnerabilities) {
            if (requiresRemediation(vulnerability)) {
                AlertVulnerability alertVulnerability = toAlertVulnerabilityView(vulnerability);
                VulnerabilitySeverityType severity = alertVulnerability.severity;
                LinkableItem vulnerabilityInfo = alertVulnerability.vulnerabilityInfo;
                if (VulnerabilitySeverityType.CRITICAL.equals(severity)) {
                    criticalVulns.add(vulnerabilityInfo);
                } else if (VulnerabilitySeverityType.HIGH.equals(severity)) {
                    highVulns.add(vulnerabilityInfo);
                } else if (VulnerabilitySeverityType.MEDIUM.equals(severity)) {
                    mediumVulns.add(vulnerabilityInfo);
                } else if (VulnerabilitySeverityType.LOW.equals(severity)) {
                    lowVulns.add(vulnerabilityInfo);
                }
            }
        }
        return new ComponentVulnerabilities(criticalVulns, highVulns, mediumVulns, lowVulns);
    }

    public boolean hasSecurityRisk(ProjectVersionComponentVersionView bomComponent) {
        RiskProfileView riskProfile = bomComponent.getSecurityRiskProfile();
        if (null == riskProfile) {
            return false;
        }

        List<RiskProfileCountsView> counts = riskProfile.getCounts();
        if (null == counts) {
            return false;
        }

        return counts
                   .stream()
                   .anyMatch(this::hasSecurityRisk);
    }

    private boolean hasSecurityRisk(RiskProfileCountsView count) {
        if (null == count) {
            return false;
        }

        switch (count.getCountType()) {
            case CRITICAL:
            case HIGH:
            case MEDIUM:
            case LOW:
            case UNKNOWN:
                return count.getCount().compareTo(BigDecimal.ZERO) > 0;
            default:
                return false;
        }
    }

    private boolean requiresRemediation(BlackDuckProjectVersionComponentVulnerabilitiesView vulnerability) {
        VulnerabilityRemediationStatusType remediationStatus = vulnerability.getRemediationStatus();
        if (null == remediationStatus) {
            return true;
        }

        switch (remediationStatus) {
            case DUPLICATE:
            case IGNORED:
            case MITIGATED:
            case PATCHED:
            case REMEDIATION_COMPLETE:
                return false;
            default:
                return true;
        }
    }

    private AlertVulnerability toAlertVulnerabilityView(BlackDuckProjectVersionComponentVulnerabilitiesView vulnerability) {
        String name = vulnerability.getId();
        String url = Optional.ofNullable(vulnerability.getHref()).map(HttpUrl::toString).orElse(null);
        String severity;

        ProjectVersionComponentVersionVulnerabilityRemediationCvss3View cvss3 = vulnerability.getCvss3();
        if (vulnerability.getUseCvss3() && null != cvss3) {
            severity = Optional.ofNullable(cvss3.getSeverity()).map(Enum::name).orElse(VulnerabilitySeverityType.HIGH.name());
        } else {
            ProjectVersionComponentVersionVulnerabilityRemediationCvss2View cvss2 = vulnerability.getCvss2();
            severity = Optional.ofNullable(cvss2.getSeverity()).map(Enum::name).orElse(VulnerabilitySeverityType.HIGH.name());
        }

        VulnerabilitySeverityType vulnSeverity = EnumUtils.getEnum(VulnerabilitySeverityType.class, severity, VulnerabilitySeverityType.HIGH);
        LinkableItem vulnInfo = new LinkableItem(LABEL_VULNERABILITY, name, url);
        return new AlertVulnerability(vulnSeverity, vulnInfo);
    }

    private static class AlertVulnerability {
        public final VulnerabilitySeverityType severity;
        public final LinkableItem vulnerabilityInfo;

        public AlertVulnerability(VulnerabilitySeverityType severity, LinkableItem vulnerabilityInfo) {
            this.severity = severity;
            this.vulnerabilityInfo = vulnerabilityInfo;
        }

    }

}

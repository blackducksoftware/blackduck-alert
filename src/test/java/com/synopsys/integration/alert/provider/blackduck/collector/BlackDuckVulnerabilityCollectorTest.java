package com.synopsys.integration.alert.provider.blackduck.collector;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.SortedSet;
import java.util.stream.Collectors;

import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.springframework.core.io.ClassPathResource;

import com.google.gson.Gson;
import com.synopsys.integration.alert.TestConstants;
import com.synopsys.integration.alert.common.enumeration.FormatType;
import com.synopsys.integration.alert.common.message.model.AggregateMessageContent;
import com.synopsys.integration.alert.common.message.model.CategoryItem;
import com.synopsys.integration.alert.common.message.model.LinkableItem;
import com.synopsys.integration.alert.common.message.model.MessageContentGroup;
import com.synopsys.integration.alert.common.workflow.filter.field.JsonExtractor;
import com.synopsys.integration.alert.common.workflow.processor.DefaultMessageContentProcessor;
import com.synopsys.integration.alert.common.workflow.processor.DigestMessageContentProcessor;
import com.synopsys.integration.alert.common.workflow.processor.MessageContentCollapser;
import com.synopsys.integration.alert.common.workflow.processor.MessageContentProcessor;
import com.synopsys.integration.alert.database.notification.NotificationContent;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProperties;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProvider;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProviderContentTypes;
import com.synopsys.integration.alert.provider.blackduck.collector.item.VulnerabilitySeverity;
import com.synopsys.integration.blackduck.api.generated.enumeration.NotificationType;
import com.synopsys.integration.blackduck.api.generated.view.VulnerabilityView;
import com.synopsys.integration.blackduck.rest.BlackDuckHttpClient;
import com.synopsys.integration.blackduck.service.BlackDuckService;
import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;
import com.synopsys.integration.exception.IntegrationException;
import com.synopsys.integration.log.Slf4jIntLogger;

public class BlackDuckVulnerabilityCollectorTest {
    public static final String HIGH_VULNERABILITY = VulnerabilitySeverity.HIGH.toString();
    public static final String MEDIUM_VULNERABILITY = VulnerabilitySeverity.MEDIUM.toString();
    public static final String LOW_VULNERABILITY = VulnerabilitySeverity.LOW.toString();
    public static final String UNKNOWN_VULNERABILITY = VulnerabilitySeverity.UNKNOWN.toString();
    private final List<MessageContentProcessor> messageContentProcessorList = Arrays.asList(new DefaultMessageContentProcessor(), new DigestMessageContentProcessor(new MessageContentCollapser()));
    private final Gson gson = new Gson();

    @Test
    public void testCollectingVulnerability() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.empty());

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);

        collector.insert(notification);
        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DEFAULT);

        final int topicCount = 3;
        final int categoryPerTopic = 15;
        final int itemCount = 4;
        assertFalse(contentGroups.isEmpty());
        assertEquals(topicCount, contentGroups.size());

        final List<CategoryItem> categoryItemList = getCategoryItems(getAggregateMessageContent(contentGroups));
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityDigest() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.empty());

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);
        collector.insert(notification);

        final int operationTypeCount = 3;
        final int messageCount = 3;
        final int itemCount = 4;
        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DIGEST);
        assertFalse(contentGroups.isEmpty());

        final List<AggregateMessageContent> aggregateMessageContents = getAggregateMessageContent(contentGroups);
        assertEquals(messageCount, aggregateMessageContents.size());

        final List<CategoryItem> categoryItemList = getCategoryItems(aggregateMessageContents);
        assertEquals(operationTypeCount * messageCount, categoryItemList.size());

        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItemsOfSameName().keySet().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityWithConnection() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityView vulnerabilityView = new VulnerabilityView();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);

        collector.insert(notification);
        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DEFAULT);

        final int messageCount = 3;
        final int categoryPerTopic = 15;
        final int itemCount = 4;
        assertFalse(contentGroups.isEmpty());
        assertEquals(messageCount, contentGroups.size());
        final List<CategoryItem> categoryItemList = getCategoryItems(getAggregateMessageContent(contentGroups));
        assertEquals(messageCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(HIGH_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityDigestWithConnection() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityView vulnerabilityView = new VulnerabilityView();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);
        collector.insert(notification);

        final int operationTypeCount = 3;
        final int messageCount = 3;
        final int itemCount = 4;
        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DIGEST);
        assertFalse(contentGroups.isEmpty());

        final List<AggregateMessageContent> aggregateMessageContentList = getAggregateMessageContent(contentGroups);
        assertEquals(messageCount, aggregateMessageContentList.size());

        final List<CategoryItem> categoryItemList = getCategoryItems(aggregateMessageContentList);
        assertEquals(operationTypeCount * messageCount, categoryItemList.size());

        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItemsOfSameName().keySet().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(HIGH_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityGetSeverityException() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityView vulnerabilityView = new VulnerabilityView();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenThrow(new IntegrationException("Test Integration Exception"));
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);

        collector.insert(notification);
        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DEFAULT);

        final int topicCount = 3;
        final int categoryPerTopic = 15;
        final int itemCount = 4;
        assertFalse(contentGroups.isEmpty());

        final List<AggregateMessageContent> aggregateMessageContenta = getAggregateMessageContent(contentGroups);
        assertEquals(topicCount, contentGroups.size());

        final List<CategoryItem> categoryItemList = getCategoryItems(aggregateMessageContenta);
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityOrdered() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityView highVulnerabilityView = new VulnerabilityView();
        highVulnerabilityView.setName("vulnerability");
        highVulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        final VulnerabilityView mediumVulnerabilityView = new VulnerabilityView();
        mediumVulnerabilityView.setName("vulnerability");
        mediumVulnerabilityView.setSeverity(MEDIUM_VULNERABILITY);

        final VulnerabilityView lowVulnerabilityView = new VulnerabilityView();
        lowVulnerabilityView.setName("vulnerability");
        lowVulnerabilityView.setSeverity(LOW_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.matches("https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0001"), Mockito.any())).thenReturn(lowVulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.matches("https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0002"), Mockito.any())).thenReturn(highVulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.matches("https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0003"), Mockito.any())).thenReturn(mediumVulnerabilityView);
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification1 = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_SIMPLE_01_JSON_PATH);
        final NotificationContent notification2 = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_SIMPLE_02_JSON_PATH);

        collector.insert(notification1);
        collector.insert(notification2);
        final List<MessageContentGroup> messageContentGroups = collector.collect(FormatType.DEFAULT);
        //        System.out.println("# of messages: " + aggregateMessageContentList.size());
        VulnerabilitySeverity previousSeverity = VulnerabilitySeverity.HIGH;
        for (final MessageContentGroup messageContentGroup : messageContentGroups) {
            for (final AggregateMessageContent aggregateMessageContent : messageContentGroup.getSubContent()) {
                //                System.out.println("KEY: " + aggregateMessageContent.getKey());
                System.out.println(aggregateMessageContent.getSubTopic());
                for (final CategoryItem categoryItem : aggregateMessageContent.getCategoryItems()) {
                    //                        System.out.println("   Category KEY: " + categoryItem.getCategoryKey());
                    //                        System.out.println("   Operation: " + categoryItem.getOperation());
                    for (final LinkableItem item : categoryItem.getItems()) {
                        if (item.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY)) {
                            final VulnerabilitySeverity current = VulnerabilitySeverity.getSeverity(item.getValue());
                            assertTrue(previousSeverity.ordinal() <= current.ordinal());
                            previousSeverity = current;
                        }
                        //                                System.out.println("        Item name: " + item.getName());
                        //                                System.out.println("        Item value: " + item.getValue());
                    }
                    //                        System.out.println("");
                }
                //                System.out.println("");
                //                System.out.println("");
            }
        }
    }

    private NotificationContent getNotificationContent(final String path) throws IOException {
        final ClassPathResource classPathResource = new ClassPathResource(path);
        final File jsonFile = classPathResource.getFile();
        final String notificationContent = FileUtils.readFileToString(jsonFile, Charset.defaultCharset());
        final Date creationDate = Date.from(Instant.now());
        return new NotificationContent(creationDate, BlackDuckProvider.COMPONENT_NAME, creationDate, NotificationType.VULNERABILITY.name(), notificationContent);
    }

    private List<AggregateMessageContent> getAggregateMessageContent(final List<MessageContentGroup> messageContentGroups) {
        return messageContentGroups
                   .stream()
                   .map(MessageContentGroup::getSubContent)
                   .flatMap(List::stream)
                   .collect(Collectors.toList());
    }

    private List<CategoryItem> getCategoryItems(final List<AggregateMessageContent> aggregateMessageContents) {
        return aggregateMessageContents
                   .stream()
                   .map(AggregateMessageContent::getCategoryItems)
                   .flatMap(SortedSet::stream)
                   .collect(Collectors.toList());
    }

}

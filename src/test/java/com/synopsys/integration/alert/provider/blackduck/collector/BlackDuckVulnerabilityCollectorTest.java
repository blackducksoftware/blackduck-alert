package com.synopsys.integration.alert.provider.blackduck.collector;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.apache.commons.io.FileUtils;
import org.junit.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.springframework.core.io.ClassPathResource;

import com.google.gson.Gson;
import com.synopsys.integration.alert.common.enumeration.FormatType;
import com.synopsys.integration.alert.common.model.AggregateMessageContent;
import com.synopsys.integration.alert.common.model.CategoryItem;
import com.synopsys.integration.alert.common.model.LinkableItem;
import com.synopsys.integration.alert.common.workflow.processor.DefaultMessageContentProcessor;
import com.synopsys.integration.alert.common.workflow.processor.DigestMessageContentProcessor;
import com.synopsys.integration.alert.common.workflow.processor.MessageContentProcessor;
import com.synopsys.integration.alert.database.entity.NotificationContent;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProperties;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProvider;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProviderContentTypes;
import com.synopsys.integration.alert.workflow.filter.field.JsonExtractor;
import com.synopsys.integration.blackduck.api.generated.enumeration.NotificationType;
import com.synopsys.integration.blackduck.api.generated.view.VulnerabilityV2View;
import com.synopsys.integration.blackduck.rest.BlackDuckRestConnection;
import com.synopsys.integration.blackduck.service.BlackDuckService;
import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;
import com.synopsys.integration.exception.IntegrationException;
import com.synopsys.integration.log.Slf4jIntLogger;

public class BlackDuckVulnerabilityCollectorTest {
    public static final String VULNERABILITY = "HIGH_VULNERABILITY";
    public static final String UNKNOWN_VULNERABILITY = "UNKNOWN";
    private final List<MessageContentProcessor> messageContentProcessorList = Arrays.asList(new DefaultMessageContentProcessor(), new DigestMessageContentProcessor());
    private final Gson gson = new Gson();

    @Test
    public void testCollectingVulnerability() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);
        Mockito.when(blackDuckProperties.createRestConnectionAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.empty());

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent();

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DEFAULT);

        final int topicCount = 3;
        final int categoryPerTopic = 15;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItemList).flatMap(List::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                            .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                            .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityDigest() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);
        Mockito.when(blackDuckProperties.createRestConnectionAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.empty());

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent();

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DIGEST);
        final int topicCount = 3;
        final int categoryPerTopic = 11;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItemList).flatMap(List::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                            .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                            .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityWithConnection() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckRestConnection restConnection = Mockito.mock(BlackDuckRestConnection.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityV2View vulnerabilityView = new VulnerabilityV2View();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createRestConnectionAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(restConnection));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(restConnection), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent();

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DEFAULT);

        final int topicCount = 3;
        final int categoryPerTopic = 15;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItemList).flatMap(List::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                            .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                            .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityDigestWithConnection() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckRestConnection restConnection = Mockito.mock(BlackDuckRestConnection.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityV2View vulnerabilityView = new VulnerabilityV2View();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createRestConnectionAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(restConnection));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(restConnection), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent();

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DIGEST);
        final int topicCount = 3;
        final int categoryPerTopic = 11;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItemList).flatMap(List::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                            .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                            .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityGetSeverityException() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckRestConnection restConnection = Mockito.mock(BlackDuckRestConnection.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityV2View vulnerabilityView = new VulnerabilityV2View();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenThrow(new IntegrationException("Test Integration Exception"));
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createRestConnectionAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(restConnection));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(restConnection), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent();

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DEFAULT);

        final int topicCount = 3;
        final int categoryPerTopic = 15;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItemList).flatMap(List::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                            .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                            .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
    }

    private NotificationContent getNotificationContent() throws IOException {
        final ClassPathResource classPathResource = new ClassPathResource("json/vulnerabilityTest.json");
        final File jsonFile = classPathResource.getFile();
        final String notificationContent = FileUtils.readFileToString(jsonFile, Charset.defaultCharset());
        final Date creationDate = Date.from(Instant.now());
        return new NotificationContent(creationDate, BlackDuckProvider.COMPONENT_NAME, creationDate, NotificationType.VULNERABILITY.name(), notificationContent);
    }
}

package com.synopsys.integration.alert.provider.blackduck.collector;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.SortedSet;
import java.util.stream.Collectors;

import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.springframework.core.io.ClassPathResource;

import com.google.gson.Gson;
import com.synopsys.integration.alert.TestConstants;
import com.synopsys.integration.alert.common.enumeration.FormatType;
import com.synopsys.integration.alert.common.message.model.AggregateMessageContent;
import com.synopsys.integration.alert.common.message.model.CategoryItem;
import com.synopsys.integration.alert.common.message.model.LinkableItem;
import com.synopsys.integration.alert.common.workflow.filter.field.JsonExtractor;
import com.synopsys.integration.alert.common.workflow.processor.DefaultMessageContentProcessor;
import com.synopsys.integration.alert.common.workflow.processor.DigestMessageContentProcessor;
import com.synopsys.integration.alert.common.workflow.processor.MessageContentProcessor;
import com.synopsys.integration.alert.database.notification.NotificationContent;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProperties;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProvider;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProviderContentTypes;
import com.synopsys.integration.blackduck.api.generated.enumeration.NotificationType;
import com.synopsys.integration.blackduck.api.generated.view.VulnerabilityView;
import com.synopsys.integration.blackduck.rest.BlackDuckHttpClient;
import com.synopsys.integration.blackduck.service.BlackDuckService;
import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;
import com.synopsys.integration.exception.IntegrationException;
import com.synopsys.integration.log.Slf4jIntLogger;

public class BlackDuckVulnerabilityCollectorTest {
    public static final String HIGH_VULNERABILITY = VulnerabilitySeverity.HIGH.toString();
    public static final String MEDIUM_VULNERABILITY = VulnerabilitySeverity.MEDIUM.toString();
    public static final String LOW_VULNERABILITY = VulnerabilitySeverity.LOW.toString();
    public static final String UNKNOWN_VULNERABILITY = VulnerabilitySeverity.UNKNOWN.toString();
    private final List<MessageContentProcessor> messageContentProcessorList = Arrays.asList(new DefaultMessageContentProcessor(), new DigestMessageContentProcessor());
    private final Gson gson = new Gson();

    @Test
    public void testCollectingVulnerability() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.empty());

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DEFAULT);

        final int topicCount = 3;
        final int categoryPerTopic = 15;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItems).flatMap(SortedSet::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityDigest() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.empty());

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DIGEST);
        final int topicCount = 3;
        final int categoryPerTopic = 11;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItems).flatMap(SortedSet::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityWithConnection() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityView vulnerabilityView = new VulnerabilityView();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DEFAULT);

        final int topicCount = 3;
        final int categoryPerTopic = 15;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItems).flatMap(SortedSet::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(HIGH_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityDigestWithConnection() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityView vulnerabilityView = new VulnerabilityView();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DIGEST);
        final int topicCount = 3;
        final int categoryPerTopic = 11;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItems).flatMap(SortedSet::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(HIGH_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityGetSeverityException() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityView vulnerabilityView = new VulnerabilityView();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenThrow(new IntegrationException("Test Integration Exception"));
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);

        collector.insert(notification);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DEFAULT);

        final int topicCount = 3;
        final int categoryPerTopic = 15;
        final int itemCount = 4;
        assertFalse(aggregateMessageContentList.isEmpty());
        assertEquals(topicCount, aggregateMessageContentList.size());
        final List<CategoryItem> categoryItemList = aggregateMessageContentList.stream().map(AggregateMessageContent::getCategoryItems).flatMap(SortedSet::stream).collect(Collectors.toList());
        assertEquals(topicCount * categoryPerTopic, categoryItemList.size());
        final CategoryItem categoryItem = categoryItemList.get(0);
        assertEquals(itemCount, categoryItem.getItems().size());
        final Optional<LinkableItem> severityItem = categoryItem.getItems().stream()
                                                        .filter(linkableItem -> linkableItem.getName().equals(BlackDuckProviderContentTypes.LABEL_VULNERABILITY_SEVERITY))
                                                        .findFirst();
        assertTrue(severityItem.isPresent());
        assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
    }

    @Test
    public void testCollectingVulnerabilityOrdered() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);

        final VulnerabilityView highVulnerabilityView = new VulnerabilityView();
        highVulnerabilityView.setName("vulnerability");
        highVulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        final VulnerabilityView mediumVulnerabilityView = new VulnerabilityView();
        mediumVulnerabilityView.setName("vulnerability");
        mediumVulnerabilityView.setSeverity(MEDIUM_VULNERABILITY);

        final VulnerabilityView lowVulnerabilityView = new VulnerabilityView();
        lowVulnerabilityView.setName("vulnerability");
        lowVulnerabilityView.setSeverity(LOW_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.matches("https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0001"), Mockito.any())).thenReturn(lowVulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.matches("https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0002"), Mockito.any())).thenReturn(highVulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.matches("https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0003"), Mockito.any())).thenReturn(mediumVulnerabilityView);
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification1 = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_SIMPLE_01_JSON_PATH);
        final NotificationContent notification2 = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_SIMPLE_02_JSON_PATH);

        collector.insert(notification1);
        collector.insert(notification2);
        final List<AggregateMessageContent> aggregateMessageContentList = collector.collect(FormatType.DEFAULT);
        System.out.println("# of messages: " + aggregateMessageContentList.size());
        aggregateMessageContentList.stream()
            .forEach(aggregateMessageContent -> {
                System.out.println("KEY: " + aggregateMessageContent.getKey());
                aggregateMessageContent.getSubTopic().ifPresent(System.out::println);

                aggregateMessageContent.getCategoryItems().stream()
                    .forEach(categoryItem -> {
                        System.out.println("   Category KEY: " + categoryItem.getCategoryKey());
                        System.out.println("   Operation: " + categoryItem.getOperation());
                        categoryItem.getItems().stream()
                            .forEach(item -> {
                                System.out.println("        Item name: " + item.getName());
                                System.out.println("        Item value: " + item.getValue());
                            });
                        System.out.println("");
                    });
                System.out.println("");
                System.out.println("");
            });
    }

    private NotificationContent getNotificationContent(final String path) throws IOException {
        final ClassPathResource classPathResource = new ClassPathResource(path);
        final File jsonFile = classPathResource.getFile();
        final String notificationContent = FileUtils.readFileToString(jsonFile, Charset.defaultCharset());
        final Date creationDate = Date.from(Instant.now());
        return new NotificationContent(creationDate, BlackDuckProvider.COMPONENT_NAME, creationDate, NotificationType.VULNERABILITY.name(), notificationContent);
    }
}

package com.blackducksoftware.integration.hub.alert.processor.vulnerability;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Test;
import org.mockito.Mockito;

import com.blackducksoftware.integration.exception.IntegrationException;
import com.blackducksoftware.integration.hub.alert.config.GlobalProperties;
import com.blackducksoftware.integration.hub.alert.datasource.entity.NotificationCategoryEnum;
import com.blackducksoftware.integration.hub.alert.mock.notification.NotificationGeneratorUtils;
import com.blackducksoftware.integration.hub.alert.processor.NotificationProcessingModel;
import com.blackducksoftware.integration.hub.api.UriSingleResponse;
import com.blackducksoftware.integration.hub.api.component.AffectedProjectVersion;
import com.blackducksoftware.integration.hub.api.core.ResourceMetadata;
import com.blackducksoftware.integration.hub.api.generated.enumeration.NotificationType;
import com.blackducksoftware.integration.hub.api.generated.view.ComponentVersionView;
import com.blackducksoftware.integration.hub.api.generated.view.NotificationView;
import com.blackducksoftware.integration.hub.api.generated.view.VulnerabilityV2View;
import com.blackducksoftware.integration.hub.notification.NotificationDetailResults;
import com.blackducksoftware.integration.hub.notification.content.VulnerabilityNotificationContent;
import com.blackducksoftware.integration.hub.notification.content.VulnerabilitySourceQualifiedId;
import com.blackducksoftware.integration.hub.notification.content.detail.NotificationContentDetail;
import com.blackducksoftware.integration.hub.service.HubService;
import com.blackducksoftware.integration.hub.service.HubServicesFactory;
import com.blackducksoftware.integration.hub.service.bucket.HubBucket;
import com.blackducksoftware.integration.hub.service.bucket.HubBucketService;
import com.blackducksoftware.integration.rest.connection.RestConnection;

public class VulnerabilityProcessingRuleTest {

    @Test
    public void testIsApplicableTrue() {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);

        final VulnerabilityNotificationContent content = new VulnerabilityNotificationContent();
        content.newVulnerabilityCount = 1;
        content.updatedVulnerabilityCount = 1;
        content.deletedVulnerabilityCount = 1;
        content.newVulnerabilityIds = createSourceIdList("1");
        content.updatedVulnerabilityIds = createSourceIdList("2");
        content.deletedVulnerabilityIds = createSourceIdList("3");
        content.componentVersion = "componentversionurl";
        createCommonContentData(content);

        final NotificationView view = NotificationGeneratorUtils.createNotificationView(NotificationType.VULNERABILITY);
        final NotificationContentDetail detail = NotificationGeneratorUtils.createNotificationDetailList(view, content).get(0);
        assertTrue(rule.isApplicable(detail));

    }

    @Test
    public void testIsApplicableFalse() {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);

        final VulnerabilityNotificationContent content = new VulnerabilityNotificationContent();
        content.newVulnerabilityCount = 1;
        content.updatedVulnerabilityCount = 1;
        content.deletedVulnerabilityCount = 1;
        content.newVulnerabilityIds = createSourceIdList("1");
        content.updatedVulnerabilityIds = createSourceIdList("2");
        content.deletedVulnerabilityIds = createSourceIdList("3");
        createCommonContentData(content);

        final NotificationView view = NotificationGeneratorUtils.createNotificationView(NotificationType.POLICY_OVERRIDE);
        final NotificationContentDetail detail = NotificationGeneratorUtils.createNotificationDetailList(view, content).get(0);
        assertFalse(rule.isApplicable(detail));
    }

    @Test
    public void testGetGlobalProperties() {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);

        assertEquals(globalProperties, rule.getGlobalProperties());
    }

    @Test
    public void testApply() throws IntegrationException {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final ComponentVersionView versionView = new ComponentVersionView();
        final Map<String, VulnerabilityProcessingModel> modelMap = new HashMap<>();

        final VulnerabilityNotificationContent content = new VulnerabilityNotificationContent();
        content.newVulnerabilityCount = 3;
        content.updatedVulnerabilityCount = 1;
        content.deletedVulnerabilityCount = 2;
        content.newVulnerabilityIds = createSourceIdList("1", "2", "5");
        content.updatedVulnerabilityIds = createSourceIdList("3");
        content.deletedVulnerabilityIds = createSourceIdList("4", "5");

        final NotificationDetailResults notificationResults = initializeTestData(globalProperties, versionView, content);
        final HubBucket bucket = notificationResults.getHubBucket();

        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);
        notificationResults.getResults().forEach(notificationViewResult -> {
            rule.apply(modelMap, notificationViewResult, bucket);
        });

        assertEquals(1, modelMap.size());
        final NotificationContentDetail contentDetail = notificationResults.getResults().get(0);
        final String key = contentDetail.getContentDetailKey();
        final NotificationProcessingModel model = modelMap.get(key);

        assertEquals(NotificationCategoryEnum.VULNERABILITY, model.getNotificationType());
        assertEquals(contentDetail, model.getContentDetail());
    }

    @Test
    public void testApplyWithSameVulnerabilityData() throws IntegrationException {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final ComponentVersionView versionView = new ComponentVersionView();
        final Map<String, VulnerabilityProcessingModel> modelMap = new HashMap<>();

        final VulnerabilityNotificationContent content = new VulnerabilityNotificationContent();
        content.newVulnerabilityCount = 3;
        content.updatedVulnerabilityCount = 1;
        content.deletedVulnerabilityCount = 2;
        content.newVulnerabilityIds = createSourceIdList("2", "3", "6");
        content.updatedVulnerabilityIds = createSourceIdList("2");
        content.deletedVulnerabilityIds = createSourceIdList("4", "5", "6");

        final NotificationDetailResults notificationResults = initializeTestData(globalProperties, versionView, content);
        final HubBucket bucket = notificationResults.getHubBucket();
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);
        notificationResults.getResults().forEach(notificationViewResult -> {
            rule.apply(modelMap, notificationViewResult, bucket);
        });

        assertEquals(1, modelMap.size());
        final NotificationContentDetail contentDetail = notificationResults.getResults().get(0);
        final String key = contentDetail.getContentDetailKey();
        final NotificationProcessingModel model = modelMap.get(key);

        assertEquals(NotificationCategoryEnum.VULNERABILITY, model.getNotificationType());
        assertEquals(contentDetail, model.getContentDetail());
    }

    @Test
    public void testApplyWith0Counts() throws IntegrationException {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final ComponentVersionView versionView = new ComponentVersionView();
        final Map<String, VulnerabilityProcessingModel> modelMap = new HashMap<>();

        final VulnerabilityNotificationContent content = new VulnerabilityNotificationContent();
        content.newVulnerabilityCount = 0;
        content.updatedVulnerabilityCount = 0;
        content.deletedVulnerabilityCount = 0;
        content.newVulnerabilityIds = createSourceIdList("1");
        content.updatedVulnerabilityIds = createSourceIdList("2");
        content.deletedVulnerabilityIds = createSourceIdList("3");

        final NotificationDetailResults notificationResults = initializeTestData(globalProperties, versionView, content);
        final HubBucket bucket = notificationResults.getHubBucket();
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);
        notificationResults.getResults().forEach(notificationViewResult -> {
            rule.apply(modelMap, notificationViewResult, bucket);
        });

        assertEquals(1, modelMap.size());
        final NotificationContentDetail contentDetail = notificationResults.getResults().get(0);
        final String key = contentDetail.getContentDetailKey();
        final VulnerabilityProcessingModel model = modelMap.get(key);

        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.HIGH_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.MEDIUM_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.LOW_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
    }

    @Test
    public void testApplyWithCancelingVulnerabilities() throws IntegrationException {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final ComponentVersionView versionView = new ComponentVersionView();
        final Map<String, VulnerabilityProcessingModel> modelMap = new HashMap<>();

        final VulnerabilityNotificationContent content = new VulnerabilityNotificationContent();
        content.newVulnerabilityCount = 1;
        content.updatedVulnerabilityCount = 1;
        content.deletedVulnerabilityCount = 1;
        content.newVulnerabilityIds = createSourceIdList("1");
        content.updatedVulnerabilityIds = createSourceIdList("2");
        content.deletedVulnerabilityIds = createSourceIdList("1");

        final NotificationDetailResults notificationResults = initializeTestData(globalProperties, versionView, content);
        final HubBucket bucket = notificationResults.getHubBucket();
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);
        notificationResults.getResults().forEach(notificationViewResult -> {
            rule.apply(modelMap, notificationViewResult, bucket);
        });

        assertEquals(1, modelMap.size());
        final NotificationContentDetail contentDetail = notificationResults.getResults().get(0);
        final String key = contentDetail.getContentDetailKey();
        final VulnerabilityProcessingModel model = modelMap.get(key);

        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.HIGH_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
        assertFalse(model.getVulnerabilityStateTable(NotificationCategoryEnum.MEDIUM_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.LOW_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
    }

    @Test
    public void testApplyWithUnknownSeverity() throws IntegrationException {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final HubServicesFactory hubServicesFactory = Mockito.mock(HubServicesFactory.class);
        final HubService hubService = Mockito.mock(HubService.class);
        final HubBucketService bucketService = Mockito.mock(HubBucketService.class);
        final ComponentVersionView versionView = new ComponentVersionView();
        final List<VulnerabilityV2View> vulnerabilityViewList = new ArrayList<>();
        final VulnerabilityV2View vulnerabilityView = new VulnerabilityV2View();
        vulnerabilityView.name = "1";
        vulnerabilityView.severity = "UNKNOWN";
        vulnerabilityView._meta = new ResourceMetadata();
        vulnerabilityView._meta.href = "href_1";
        vulnerabilityViewList.add(vulnerabilityView);
        final RestConnection restConnection = Mockito.mock(RestConnection.class);

        Mockito.when(globalProperties.createRestConnectionAndLogErrors(Mockito.any())).thenReturn(restConnection);
        Mockito.when(globalProperties.createHubServicesFactory(Mockito.any())).thenReturn(hubServicesFactory);
        Mockito.when(hubServicesFactory.createHubService()).thenReturn(hubService);
        Mockito.when(hubServicesFactory.createHubBucketService()).thenReturn(bucketService);
        Mockito.when(hubService.getResponse(Mockito.any(UriSingleResponse.class))).thenReturn(versionView);
        Mockito.when(hubService.getAllResponses(versionView, ComponentVersionView.VULNERABILITIES_LINK_RESPONSE)).thenReturn(vulnerabilityViewList);
        final Map<String, VulnerabilityProcessingModel> modelMap = new HashMap<>();

        final NotificationView view = NotificationGeneratorUtils.createNotificationView(NotificationType.VULNERABILITY);

        final VulnerabilityNotificationContent content = new VulnerabilityNotificationContent();
        content.newVulnerabilityCount = 1;
        content.updatedVulnerabilityCount = 0;
        content.deletedVulnerabilityCount = 0;
        content.newVulnerabilityIds = createSourceIdList("1");
        content.updatedVulnerabilityIds = createSourceIdList("2");
        content.deletedVulnerabilityIds = createSourceIdList("1");
        createCommonContentData(content);

        final List<NotificationContentDetail> detailList = NotificationGeneratorUtils.createNotificationDetailList(view, content);
        final NotificationDetailResults notificationResults = NotificationGeneratorUtils.createNotificationResults(detailList);
        final HubBucket bucket = notificationResults.getHubBucket();
        bucket.addValid(content.componentVersion, versionView);
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);
        notificationResults.getResults().forEach(notificationViewResult -> {
            rule.apply(modelMap, notificationViewResult, bucket);
        });

        assertEquals(1, modelMap.size());
        final NotificationContentDetail contentDetail = notificationResults.getResults().get(0);
        final String key = contentDetail.getContentDetailKey();
        final VulnerabilityProcessingModel model = modelMap.get(key);

        // the VULNERABILITY type is ignored it should not be present only high, medium, or low exist.
        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.VULNERABILITY).getFlatVulnerabilityList().isEmpty());
        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.HIGH_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.MEDIUM_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.LOW_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
    }

    @Test
    public void testApplyWithMultipleNotifications() throws IntegrationException {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final ComponentVersionView versionView = new ComponentVersionView();
        final Map<String, VulnerabilityProcessingModel> modelMap = new HashMap<>();

        final VulnerabilityNotificationContent content_1 = new VulnerabilityNotificationContent();
        content_1.newVulnerabilityCount = 1;
        content_1.updatedVulnerabilityCount = 0;
        content_1.deletedVulnerabilityCount = 0;
        content_1.newVulnerabilityIds = createSourceIdList("1");
        content_1.updatedVulnerabilityIds = createSourceIdList("0");
        content_1.deletedVulnerabilityIds = createSourceIdList("0");

        final VulnerabilityNotificationContent content_2 = new VulnerabilityNotificationContent();
        content_2.newVulnerabilityCount = 0;
        content_2.updatedVulnerabilityCount = 0;
        content_2.deletedVulnerabilityCount = 1;
        content_2.newVulnerabilityIds = createSourceIdList("0");
        content_2.updatedVulnerabilityIds = createSourceIdList("0");
        content_2.deletedVulnerabilityIds = createSourceIdList("1");

        final NotificationDetailResults notificationResults = initializeTestData(globalProperties, versionView, content_1, content_2);
        final HubBucket bucket = notificationResults.getHubBucket();
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);
        notificationResults.getResults().forEach(notificationViewResult -> {
            rule.apply(modelMap, notificationViewResult, bucket);
        });

        assertEquals(1, modelMap.size());
        final NotificationContentDetail contentDetail = notificationResults.getResults().get(0);
        final String key = contentDetail.getContentDetailKey();
        final VulnerabilityProcessingModel model = modelMap.get(key);

        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.HIGH_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.MEDIUM_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
        assertTrue(model.getVulnerabilityStateTable(NotificationCategoryEnum.LOW_VULNERABILITY).getFlatVulnerabilityList().isEmpty());
    }

    @Test
    public void testBucketServiceException() throws IntegrationException {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final ComponentVersionView versionView = new ComponentVersionView();
        final Map<String, VulnerabilityProcessingModel> modelMap = new HashMap<>();
        final HubServicesFactory hubServicesFactory = Mockito.mock(HubServicesFactory.class);
        final HubService hubService = Mockito.mock(HubService.class);
        final HubBucketService bucketService = Mockito.mock(HubBucketService.class);
        final List<VulnerabilityV2View> vulnerabilityViewList = createVulnerabilityList();
        final RestConnection restConnection = Mockito.mock(RestConnection.class);

        Mockito.when(globalProperties.createRestConnectionAndLogErrors(Mockito.any())).thenReturn(restConnection);
        Mockito.when(globalProperties.createHubServicesFactory(Mockito.any())).thenReturn(hubServicesFactory);
        Mockito.when(hubServicesFactory.createHubService()).thenReturn(hubService);
        Mockito.when(hubServicesFactory.createHubBucketService()).thenReturn(bucketService);
        Mockito.doThrow(new IntegrationException()).when(bucketService).addToTheBucket(Mockito.any(HubBucket.class), Mockito.any(List.class));
        Mockito.when(hubService.getResponse(Mockito.any(UriSingleResponse.class))).thenReturn(versionView);
        Mockito.when(hubService.getAllResponses(versionView, ComponentVersionView.VULNERABILITIES_LINK_RESPONSE)).thenReturn(vulnerabilityViewList);
        final NotificationView view = NotificationGeneratorUtils.createNotificationView(NotificationType.VULNERABILITY);

        final VulnerabilityNotificationContent content = new VulnerabilityNotificationContent();
        content.newVulnerabilityCount = 1;
        content.updatedVulnerabilityCount = 1;
        content.deletedVulnerabilityCount = 1;
        content.newVulnerabilityIds = createSourceIdList("1");
        content.updatedVulnerabilityIds = createSourceIdList("2");
        content.deletedVulnerabilityIds = createSourceIdList("1");
        createCommonContentData(content);

        final List<NotificationContentDetail> detailList = NotificationGeneratorUtils.createNotificationDetailList(view, content);
        final NotificationDetailResults notificationResults = NotificationGeneratorUtils.createNotificationResults(detailList);
        final HubBucket bucket = notificationResults.getHubBucket();
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);
        notificationResults.getResults().forEach(notificationViewResult -> {
            rule.apply(modelMap, notificationViewResult, bucket);
        });
        assertTrue(modelMap.isEmpty());
    }

    @Test
    public void testBucketServiceExceptionOnVersionViewHrefExists() throws IntegrationException {
        final GlobalProperties globalProperties = Mockito.mock(GlobalProperties.class);
        final ComponentVersionView versionView = new ComponentVersionView();
        final Map<String, VulnerabilityProcessingModel> modelMap = new HashMap<>();
        final HubServicesFactory hubServicesFactory = Mockito.mock(HubServicesFactory.class);
        final HubService hubService = Mockito.mock(HubService.class);
        final HubBucketService bucketService = Mockito.mock(HubBucketService.class);
        final List<VulnerabilityV2View> vulnerabilityViewList = createVulnerabilityList();
        final RestConnection restConnection = Mockito.mock(RestConnection.class);

        Mockito.when(globalProperties.createRestConnectionAndLogErrors(Mockito.any())).thenReturn(restConnection);
        Mockito.when(globalProperties.createHubServicesFactory(Mockito.any())).thenReturn(hubServicesFactory);
        Mockito.when(hubServicesFactory.createHubService()).thenReturn(hubService);
        Mockito.when(hubServicesFactory.createHubBucketService()).thenReturn(bucketService);
        Mockito.doThrow(new IntegrationException()).when(bucketService).addToTheBucket(Mockito.any(HubBucket.class), Mockito.any(List.class));
        Mockito.when(hubService.getResponse(Mockito.any(UriSingleResponse.class))).thenReturn(versionView);
        Mockito.when(hubService.getAllResponses(versionView, ComponentVersionView.VULNERABILITIES_LINK_RESPONSE)).thenReturn(vulnerabilityViewList);
        final NotificationView view = NotificationGeneratorUtils.createNotificationView(NotificationType.VULNERABILITY);

        final VulnerabilityNotificationContent content = new VulnerabilityNotificationContent();
        content.newVulnerabilityCount = 1;
        content.updatedVulnerabilityCount = 1;
        content.deletedVulnerabilityCount = 1;
        content.newVulnerabilityIds = createSourceIdList("1");
        content.updatedVulnerabilityIds = createSourceIdList("2");
        content.deletedVulnerabilityIds = createSourceIdList("1");
        createCommonContentData(content);

        final List<NotificationContentDetail> detailList = NotificationGeneratorUtils.createNotificationDetailList(view, content);
        final NotificationDetailResults notificationResults = NotificationGeneratorUtils.createNotificationResults(detailList);
        final HubBucket bucket = notificationResults.getHubBucket();
        bucket.addValid(content.componentVersion, versionView);
        final VulnerabilityProcessingRule rule = new VulnerabilityProcessingRule(globalProperties);
        notificationResults.getResults().forEach(notificationViewResult -> {
            rule.apply(modelMap, notificationViewResult, bucket);
        });
        assertFalse(modelMap.isEmpty());
    }

    private NotificationDetailResults initializeTestData(final GlobalProperties globalProperties, final ComponentVersionView versionView, final VulnerabilityNotificationContent... contents) throws IntegrationException {
        final HubServicesFactory hubServicesFactory = Mockito.mock(HubServicesFactory.class);
        final HubService hubService = Mockito.mock(HubService.class);
        final HubBucketService bucketService = Mockito.mock(HubBucketService.class);
        final List<VulnerabilityV2View> vulnerabilityViewList = createVulnerabilityList();
        final RestConnection restConnection = Mockito.mock(RestConnection.class);

        Mockito.when(globalProperties.createRestConnectionAndLogErrors(Mockito.any())).thenReturn(restConnection);
        Mockito.when(globalProperties.createHubServicesFactory(Mockito.any())).thenReturn(hubServicesFactory);
        Mockito.when(hubServicesFactory.createHubService()).thenReturn(hubService);
        Mockito.when(hubServicesFactory.createHubBucketService()).thenReturn(bucketService);
        Mockito.when(hubService.getResponse(Mockito.any(UriSingleResponse.class))).thenReturn(versionView);
        Mockito.when(hubService.getAllResponses(versionView, ComponentVersionView.VULNERABILITIES_LINK_RESPONSE)).thenReturn(vulnerabilityViewList);
        final NotificationView view = NotificationGeneratorUtils.createNotificationView(NotificationType.VULNERABILITY);
        final List<NotificationContentDetail> detailList = new ArrayList<>();
        for (final VulnerabilityNotificationContent content : contents) {
            createCommonContentData(content);
            final List<NotificationContentDetail> contentDetailList = NotificationGeneratorUtils.createNotificationDetailList(view, content);
            detailList.addAll(contentDetailList);
        }

        final NotificationDetailResults notificationResults = NotificationGeneratorUtils.createNotificationResults(detailList);
        final HubBucket bucket = notificationResults.getHubBucket();
        // need to map the component version uri to a view in order for the processing rule to work
        // otherwise the rule will always have an empty list
        bucket.addValid(contents[0].componentVersion, versionView);
        return notificationResults;
    }

    private void createCommonContentData(final VulnerabilityNotificationContent content) {
        final AffectedProjectVersion affectedProjectVersion = new AffectedProjectVersion();
        affectedProjectVersion.projectName = "VulnerableProjectName";
        affectedProjectVersion.projectVersionName = "1.2.3";
        affectedProjectVersion.projectVersion = "projectURL";
        affectedProjectVersion.componentIssueUrl = "componentIssueUrl";

        content.componentVersion = "componentversionurl";
        content.componentName = "VulnerableComponent";
        content.versionName = "1.2.3";
        content.componentVersionOriginName = "originName";
        content.affectedProjectVersions = Arrays.asList(affectedProjectVersion);
        content.componentVersionOriginId = "originId";
    }

    private List<VulnerabilitySourceQualifiedId> createSourceIdList(final String... ids) {
        final List<VulnerabilitySourceQualifiedId> sourceIdList = new ArrayList<>(ids.length);
        for (final String id : ids) {
            final VulnerabilitySourceQualifiedId vuln = new VulnerabilitySourceQualifiedId();
            vuln.vulnerabilityId = id;
            sourceIdList.add(vuln);
        }
        return sourceIdList;
    }

    private List<VulnerabilityV2View> createVulnerabilityList() {
        final VulnerabilityV2View vuln_1 = new VulnerabilityV2View();
        vuln_1.name = "1";
        vuln_1.severity = "LOW";
        vuln_1._meta = new ResourceMetadata();
        vuln_1._meta.href = "href_1";

        final VulnerabilityV2View vuln_2 = new VulnerabilityV2View();
        vuln_2.name = "2";
        vuln_2.severity = "MEDIUM";
        vuln_2._meta = new ResourceMetadata();
        vuln_2._meta.href = "href_2";

        final VulnerabilityV2View vuln_3 = new VulnerabilityV2View();
        vuln_3.name = "3";
        vuln_3.severity = "HIGH";
        vuln_3._meta = new ResourceMetadata();
        vuln_3._meta.href = "href_3";

        return Arrays.asList(vuln_1, vuln_2, vuln_3);
    }
}

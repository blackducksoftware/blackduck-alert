/**
 * hub-alert
 *
 * Copyright (C) 2018 Black Duck Software, Inc.
 * http://www.blackducksoftware.com/
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.blackducksoftware.integration.hub.alert.processor.vulnerability;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.blackducksoftware.integration.exception.IntegrationException;
import com.blackducksoftware.integration.hub.alert.config.GlobalProperties;
import com.blackducksoftware.integration.hub.alert.datasource.entity.NotificationCategoryEnum;
import com.blackducksoftware.integration.hub.alert.datasource.entity.VulnerabilityEntity;
import com.blackducksoftware.integration.hub.alert.enumeration.VulnerabilityOperationEnum;
import com.blackducksoftware.integration.hub.alert.processor.NotificationProcessingRule;
import com.blackducksoftware.integration.hub.api.generated.enumeration.NotificationType;
import com.blackducksoftware.integration.hub.api.generated.view.ComponentVersionView;
import com.blackducksoftware.integration.hub.api.generated.view.VulnerabilityV2View;
import com.blackducksoftware.integration.hub.notification.NotificationDetailResult;
import com.blackducksoftware.integration.hub.notification.content.VulnerabilityNotificationContent;
import com.blackducksoftware.integration.hub.notification.content.VulnerabilitySourceQualifiedId;
import com.blackducksoftware.integration.hub.notification.content.detail.NotificationContentDetail;
import com.blackducksoftware.integration.hub.service.HubService;
import com.blackducksoftware.integration.hub.service.HubServicesFactory;
import com.blackducksoftware.integration.hub.service.bucket.HubBucket;
import com.blackducksoftware.integration.hub.service.bucket.HubBucketService;
import com.blackducksoftware.integration.rest.connection.RestConnection;

public class VulnerabilityProcessingRule extends NotificationProcessingRule<VulnerabilityProcessingModel> {
    final Logger logger = LoggerFactory.getLogger(VulnerabilityProcessingRule.class);

    public VulnerabilityProcessingRule(final GlobalProperties globalProperties) {
        super(globalProperties, NotificationType.VULNERABILITY);
    }

    @Override
    public void apply(final Map<String, VulnerabilityProcessingModel> modelMap, final NotificationDetailResult notificationDetailResult, final HubBucket bucket) {
        try (RestConnection restConnection = getGlobalProperties().createRestConnectionAndLogErrors(logger)) {
            if (restConnection != null) {
                final VulnerabilityNotificationContent content = (VulnerabilityNotificationContent) notificationDetailResult.getNotificationContent();
                final HubServicesFactory hubServicesFactory = getGlobalProperties().createHubServicesFactory(restConnection);
                final HubService hubService = hubServicesFactory.createHubService();
                final HubBucketService bucketService = hubServicesFactory.createHubBucketService();
                final Map<String, VulnerabilityV2View> vulnerabilityViewMap = new HashMap<>(50);
                handleVulnerabilty(modelMap, bucket, vulnerabilityViewMap, content, notificationDetailResult, bucketService, hubService);
            }
        } catch (final IOException e) {
            logger.error(e.getMessage(), e);
        }
    }

    private void handleVulnerabilty(final Map<String, VulnerabilityProcessingModel> modelMap, final HubBucket bucket, final Map<String, VulnerabilityV2View> vulnerabilityViewMap,
            final VulnerabilityNotificationContent content,
            final NotificationDetailResult notificationDetailResult, final HubBucketService bucketService, final HubService hubService) {
        final String key = notificationDetailResult.getContentDetailKey();
        try {
            manageVulnerabiltyViewMap(vulnerabilityViewMap, notificationDetailResult, bucketService, bucket, hubService);
            final VulnerabilityProcessingModel model = findOrCreateNotificationModel(key, modelMap, notificationDetailResult);
            manageModelVulnerabilityData(vulnerabilityViewMap, content, model);
        } catch (final IntegrationException ex) {
            logger.error("Vulnerabilty rule processing error", ex);
        }
    }

    private void manageVulnerabiltyViewMap(final Map<String, VulnerabilityV2View> vulnerabilityViewMap, final NotificationDetailResult notificationDetailResult, final HubBucketService bucketService, final HubBucket bucket,
            final HubService hubService)
            throws IntegrationException {
        final NotificationContentDetail detail = notificationDetailResult.getNotificationContentDetail();
        if (detail.getComponentVersion().isPresent()) {
            final String uri = detail.getComponentVersion().get().uri;
            if (!bucket.contains(uri)) {
                bucketService.addToTheBucket(bucket, Arrays.asList(detail.getComponentVersion().get()));
            }
            final ComponentVersionView versionView = bucket.get(detail.getComponentVersion().get());
            final List<VulnerabilityV2View> vulnerabilityList = hubService.getAllResponses(versionView, ComponentVersionView.VULNERABILITIES_LINK_RESPONSE);
            vulnerabilityList.forEach(vulnerability -> {
                if (!vulnerabilityViewMap.containsKey(vulnerability.name)) {
                    vulnerabilityViewMap.put(vulnerability.name, vulnerability);
                    try {
                        bucketService.addToTheBucket(bucket, vulnerability._meta.href, VulnerabilityV2View.class);
                    } catch (final IntegrationException ex) {
                        logger.error("Attempting to add vulnerability {} to bucket failed", ex);
                    }
                }
            });
        }
    }

    private VulnerabilityProcessingModel findOrCreateNotificationModel(final String key, final Map<String, VulnerabilityProcessingModel> modelMap,
            final NotificationDetailResult notificationDetailResult) {
        VulnerabilityProcessingModel model;
        if (modelMap.containsKey(key)) {
            model = modelMap.get(key);
        } else {
            model = createProcessingModel(notificationDetailResult);
            modelMap.put(key, model);
        }
        return model;
    }

    private VulnerabilityProcessingModel createProcessingModel(final NotificationDetailResult notificationDetailResult) {
        // have 3 notification types we are interested in high, medium, and low
        final Map<NotificationCategoryEnum, VulnerabilityStateTable> vulnerabiltyStateTableMap = new HashMap<>(3);
        vulnerabiltyStateTableMap.put(NotificationCategoryEnum.HIGH_VULNERABILITY, new VulnerabilityStateTable());
        vulnerabiltyStateTableMap.put(NotificationCategoryEnum.MEDIUM_VULNERABILITY, new VulnerabilityStateTable());
        vulnerabiltyStateTableMap.put(NotificationCategoryEnum.LOW_VULNERABILITY, new VulnerabilityStateTable());
        return new VulnerabilityProcessingModel(notificationDetailResult, NotificationCategoryEnum.VULNERABILITY, vulnerabiltyStateTableMap);
    }

    private void manageModelVulnerabilityData(final Map<String, VulnerabilityV2View> vulnerabilityViewMap, final VulnerabilityNotificationContent content, final VulnerabilityProcessingModel procesingModel) {
        if (content.newVulnerabilityCount > 0) {
            content.newVulnerabilityIds.forEach(item -> {
                addToVulnerabilityTable(vulnerabilityViewMap, VulnerabilityOperationEnum.ADD, procesingModel, item);
            });
        }

        if (content.updatedVulnerabilityCount > 0) {
            content.updatedVulnerabilityIds.forEach(item -> {
                addToVulnerabilityTable(vulnerabilityViewMap, VulnerabilityOperationEnum.UPDATE, procesingModel, item);
            });
        }

        if (content.deletedVulnerabilityCount > 0) {
            content.deletedVulnerabilityIds.forEach(item -> {
                addToVulnerabilityTable(vulnerabilityViewMap, VulnerabilityOperationEnum.DELETE, procesingModel, item);
            });
        }
    }

    private void addToVulnerabilityTable(final Map<String, VulnerabilityV2View> vulnerabilityViewMap, final VulnerabilityOperationEnum operation, final VulnerabilityProcessingModel processingModel,
            final VulnerabilitySourceQualifiedId item) {
        if (vulnerabilityViewMap.containsKey(item.vulnerabilityId)) {
            final VulnerabilityV2View vulnerabilityView = vulnerabilityViewMap.get(item.vulnerabilityId);
            final NotificationCategoryEnum notificationType = getVulnerabilityCategory(vulnerabilityView.severity);
            final VulnerabilityStateTable vulnerabilityStateTable = processingModel.getVulnerabilityStateTable(notificationType);
            vulnerabilityStateTable.addVulnerabilityData(operation, createEntityFromSourceQualifiedId(item, operation));
        }
    }

    private NotificationCategoryEnum getVulnerabilityCategory(final String severityString) {
        final String severity = severityString.toUpperCase();

        if (severity.equals("HIGH")) {
            return NotificationCategoryEnum.HIGH_VULNERABILITY;
        } else if (severity.equals("MEDIUM")) {
            return NotificationCategoryEnum.MEDIUM_VULNERABILITY;
        } else if (severity.equals("LOW")) {
            return NotificationCategoryEnum.LOW_VULNERABILITY;
        } else {
            return NotificationCategoryEnum.VULNERABILITY;
        }
    }

    private VulnerabilityEntity createEntityFromSourceQualifiedId(final VulnerabilitySourceQualifiedId item, final VulnerabilityOperationEnum operation) {
        return new VulnerabilityEntity(item.vulnerabilityId, operation, null);
    }
}

/**
 * hub-alert
 *
 * Copyright (C) 2018 Black Duck Software, Inc.
 * http://www.blackducksoftware.com/
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.blackducksoftware.integration.hub.alert.processor;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.blackducksoftware.integration.exception.IntegrationException;
import com.blackducksoftware.integration.hub.api.generated.view.ComponentVersionView;
import com.blackducksoftware.integration.hub.api.generated.view.VulnerabilityV2View;
import com.blackducksoftware.integration.hub.exception.HubIntegrationException;
import com.blackducksoftware.integration.hub.notification.ItemTypeEnum;
import com.blackducksoftware.integration.hub.notification.NotificationCategoryEnum;
import com.blackducksoftware.integration.hub.notification.NotificationEvent;
import com.blackducksoftware.integration.hub.notification.VulnerabilityContentItem;
import com.blackducksoftware.integration.hub.service.HubServicesFactory;
import com.blackducksoftware.integration.hub.service.ProjectService;

public class VulnerabilityCache extends UserNotificationCache {
    public final static String VULNERABILITY_ID_SET = "vulnerabilityIdSet";
    public final static String VULNERABILITY_OPERATION = "vulnerabilityOperation";
    private final HubServicesFactory hubServicesFactory;

    public VulnerabilityCache(final ProjectService projectService, final HubServicesFactory hubServicesFactory) {
        super(projectService);
        this.hubServicesFactory = hubServicesFactory;
    }

    // The dataset contains string keys and object values. Therefore we need to type cast because the contents are various types.
    @SuppressWarnings("unchecked")
    @Override
    public void addEvent(final NotificationEvent event) {
        final String key = event.getEventKey();
        if (!hasEvent(key)) {
            getEventMap().put(key, event);
        } else {
            final NotificationEvent storedEvent = getEventMap().get(key);
            final Map<String, Object> storedEventDataMap = storedEvent.getDataSet();
            final Map<String, Object> eventDataMap = event.getDataSet();
            final Set<String> eventVulnIdSet = (Set<String>) eventDataMap.get(VULNERABILITY_ID_SET);
            final Set<String> storedVulnIdSet = (Set<String>) storedEventDataMap.get(VULNERABILITY_ID_SET);
            if (!eventVulnIdSet.isEmpty()) {
                storedVulnIdSet.addAll(eventVulnIdSet);
            }
        }
    }

    // The dataset contains string keys and object values. Therefore we need to type cast because the contents are various types.
    @SuppressWarnings("unchecked")
    @Override
    public void removeEvent(final NotificationEvent event) {
        final String key = event.getEventKey();
        if (hasEvent(key)) {
            final NotificationEvent storedEvent = getEventMap().get(key);
            final Map<String, Object> storedEventDataMap = storedEvent.getDataSet();
            final Map<String, Object> eventDataMap = event.getDataSet();
            final Set<String> eventVulnIdSet = (Set<String>) eventDataMap.get(VULNERABILITY_ID_SET);
            final Set<String> storedVulnIdSet = (Set<String>) storedEventDataMap.get(VULNERABILITY_ID_SET);
            if (!eventVulnIdSet.isEmpty()) {
                storedVulnIdSet.addAll(eventVulnIdSet);
            }

            if (!storedVulnIdSet.isEmpty() && !eventVulnIdSet.isEmpty()) {
                storedVulnIdSet.removeAll(eventVulnIdSet);
            }

            if (storedVulnIdSet.isEmpty()) {
                removeEvent(key);
            }
        } else {
            addEvent(event);
        }
    }

    @Override
    public Collection<NotificationEvent> getEvents() throws HubIntegrationException {
        final Collection<NotificationEvent> vulnerabilities = super.getEvents();
        // need to group the vulnerabilities by severity which can be gathered by the vulnerability API.
        final Collection<NotificationEvent> result = new LinkedList<>();
        for (final NotificationEvent event : vulnerabilities) {
            List<NotificationEvent> vulnerabilityEvents;
            try {
                vulnerabilityEvents = createVulnerabilityEvents(event);
            } catch (final IntegrationException e) {
                throw new HubIntegrationException(e);
            }
            for (final NotificationEvent vulnerability : vulnerabilityEvents) {
                result.add(vulnerability);
            }
        }

        return this.addUserInformation(result);
    }

    private List<NotificationEvent> createVulnerabilityEvents(final NotificationEvent originalEvent) throws IntegrationException {
        final List<NotificationEvent> eventList = new LinkedList<>();
        final VulnerabilityContentItem vulnerabilityContent = (VulnerabilityContentItem) originalEvent.getDataSet().get(NotificationEvent.DATA_SET_KEY_NOTIFICATION_CONTENT);

        final List<VulnerabilityV2View> vulnerabilityList = hubServicesFactory.createHubService().getAllResponses(vulnerabilityContent.getComponentVersion(), ComponentVersionView.VULNERABILITIES_LINK_RESPONSE);
        addEventsToList(originalEvent, vulnerabilityList, eventList);
        addCountsToDataSet(eventList);
        return eventList;
    }

    @SuppressWarnings("unchecked")
    private void addEventsToList(final NotificationEvent originalEvent, final List<VulnerabilityV2View> vulnerabilityList, final List<NotificationEvent> eventList) {
        final Map<NotificationCategoryEnum, NotificationEvent> eventMap = new HashMap<>();
        final Set<String> eventVulnIdSet = (Set<String>) originalEvent.getDataSet().get(VULNERABILITY_ID_SET);
        for (final String vulnId : eventVulnIdSet) {
            for (final VulnerabilityV2View vulnerability : vulnerabilityList) {
                final NotificationCategoryEnum eventCategory = getEventCategory(vulnerability.severity);
                final String vulnName = vulnerability.name;
                if (vulnId.equals(vulnName)) {
                    if (eventMap.containsKey(eventCategory)) {
                        final NotificationEvent event = eventMap.get(eventCategory);
                        final Set<String> vulnSet = (Set<String>) event.getDataSet().get(VULNERABILITY_ID_SET);
                        vulnSet.add(vulnName);
                    } else {
                        final Set<String> vulnset = new HashSet<>();
                        vulnset.add(vulnName);
                        final Map<String, Object> dataSet = new HashMap<>(originalEvent.getDataSet());
                        dataSet.put(VULNERABILITY_ID_SET, vulnset);
                        final NotificationEvent event = new NotificationEvent(originalEvent.getEventKey(), eventCategory, dataSet);
                        eventMap.put(eventCategory, event);
                        eventList.add(event);
                    }
                }
            }
        }
    }

    private NotificationCategoryEnum getEventCategory(final String severityString) {
        final String severity = severityString.toUpperCase();

        if (severity.equals("HIGH")) {
            return NotificationCategoryEnum.HIGH_VULNERABILITY;
        } else if (severity.equals("MEDIUM")) {
            return NotificationCategoryEnum.MEDIUM_VULNERABILITY;
        } else if (severity.equals("LOW")) {
            return NotificationCategoryEnum.LOW_VULNERABILITY;
        } else {
            return NotificationCategoryEnum.VULNERABILITY;
        }
    }

    @SuppressWarnings("unchecked")
    private void addCountsToDataSet(final List<NotificationEvent> eventList) {
        for (final NotificationEvent event : eventList) {
            final Set<String> eventVulnIdSet = (Set<String>) event.getDataSet().get(VULNERABILITY_ID_SET);
            final int size = eventVulnIdSet.size();
            if (size > 1) {
                event.getDataSet().put(ItemTypeEnum.COUNT.name(), new Integer(size));
            }
        }
    }

}

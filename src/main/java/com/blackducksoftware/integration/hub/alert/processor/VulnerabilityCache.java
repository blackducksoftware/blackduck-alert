/**
 * Copyright (C) 2017 Black Duck Software, Inc.
 * http://www.blackducksoftware.com/
 *
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.blackducksoftware.integration.hub.alert.processor;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;

import com.blackducksoftware.integration.exception.IntegrationException;
import com.blackducksoftware.integration.hub.api.item.MetaService;
import com.blackducksoftware.integration.hub.api.project.ProjectAssignmentRequestService;
import com.blackducksoftware.integration.hub.api.project.ProjectRequestService;
import com.blackducksoftware.integration.hub.api.vulnerability.VulnerabilityRequestService;
import com.blackducksoftware.integration.hub.dataservice.notification.model.VulnerabilityContentItem;
import com.blackducksoftware.integration.hub.exception.HubIntegrationException;
import com.blackducksoftware.integration.hub.model.enumeration.VulnerabilitySeverityEnum;
import com.blackducksoftware.integration.hub.model.view.ComponentVersionView;
import com.blackducksoftware.integration.hub.model.view.VulnerabilityView;
import com.blackducksoftware.integration.hub.notification.processor.ItemTypeEnum;
import com.blackducksoftware.integration.hub.notification.processor.NotificationCategoryEnum;
import com.blackducksoftware.integration.hub.notification.processor.event.NotificationEvent;
import com.blackducksoftware.integration.hub.service.HubResponseService;

public class VulnerabilityCache extends UserNotificationCache {

    public final static String VULNERABILITY_ID_SET = "vulnerabilityIdSet";
    public final static String VULNERABILITY_OPERATION = "vulnerabilityOperation";

    private final HubResponseService hubResponseService;

    private final VulnerabilityRequestService vulnerabilityRequestService;

    private final MetaService metaService;

    public VulnerabilityCache(final ProjectRequestService projectRequestService, final ProjectAssignmentRequestService projectAssignmentRequestService, final HubResponseService hubResponseService,
            final VulnerabilityRequestService vulnerabilityRequestService, final MetaService metaService) {
        super(projectRequestService, projectAssignmentRequestService, metaService);
        this.hubResponseService = hubResponseService;
        this.vulnerabilityRequestService = vulnerabilityRequestService;
        this.metaService = metaService;
    }

    // The dataset contains string keys and object values. Therefore we need to type cast because the contents are various types.
    @SuppressWarnings("unchecked")
    @Override
    public void addEvent(final NotificationEvent event) {
        final String key = event.getEventKey();
        if (!hasEvent(key)) {
            getEventMap().put(key, event);
        } else {
            final NotificationEvent storedEvent = getEventMap().get(key);
            final Map<String, Object> storedEventDataMap = storedEvent.getDataSet();
            final Map<String, Object> eventDataMap = event.getDataSet();
            final Set<String> eventVulnIdSet = (Set<String>) eventDataMap.get(VULNERABILITY_ID_SET);
            final Set<String> storedVulnIdSet = (Set<String>) storedEventDataMap.get(VULNERABILITY_ID_SET);
            if (!eventVulnIdSet.isEmpty()) {
                storedVulnIdSet.addAll(eventVulnIdSet);
            }
        }
    }

    // The dataset contains string keys and object values. Therefore we need to type cast because the contents are various types.
    @SuppressWarnings("unchecked")
    @Override
    public void removeEvent(final NotificationEvent event) {
        final String key = event.getEventKey();
        if (hasEvent(key)) {
            final NotificationEvent storedEvent = getEventMap().get(key);
            final Map<String, Object> storedEventDataMap = storedEvent.getDataSet();
            final Map<String, Object> eventDataMap = event.getDataSet();
            final Set<String> eventVulnIdSet = (Set<String>) eventDataMap.get(VULNERABILITY_ID_SET);
            final Set<String> storedVulnIdSet = (Set<String>) storedEventDataMap.get(VULNERABILITY_ID_SET);
            if (!eventVulnIdSet.isEmpty()) {
                storedVulnIdSet.addAll(eventVulnIdSet);
            }

            if (!storedVulnIdSet.isEmpty() && !eventVulnIdSet.isEmpty()) {
                storedVulnIdSet.removeAll(eventVulnIdSet);
            }

            if (storedVulnIdSet.isEmpty()) {
                removeEvent(key);
            }
        } else {
            addEvent(event);
        }
    }

    @Override
    public Collection<NotificationEvent> getEvents() throws HubIntegrationException {
        final Collection<NotificationEvent> vulnerabilities = super.getEvents();
        // need to group the vulnerabilities by severity which can be gathered by the vulnerability API.
        final Collection<NotificationEvent> result = new LinkedList<>();
        for (final NotificationEvent event : vulnerabilities) {
            List<NotificationEvent> vulnerabilityEvents;
            try {
                vulnerabilityEvents = createVulnerabilityEvents(event);
            } catch (final IntegrationException e) {
                throw new HubIntegrationException(e);
            }
            for (final NotificationEvent vulnerability : vulnerabilityEvents) {
                result.add(vulnerability);
            }
        }

        return this.addUserInformation(result);
    }

    private List<NotificationEvent> createVulnerabilityEvents(final NotificationEvent originalEvent) throws IntegrationException {
        final List<NotificationEvent> eventList = new LinkedList<>();
        final VulnerabilityContentItem vulnerabilityContent = (VulnerabilityContentItem) originalEvent.getDataSet().get(NotificationEvent.DATA_SET_KEY_NOTIFICATION_CONTENT);
        final String vulnerabilityUrl = findVulnerabilityUrl(vulnerabilityContent.getComponentVersionUrl());
        final List<VulnerabilityView> vulnerabilityList = createVulnerabilityItemList(vulnerabilityUrl);
        addEventsToList(originalEvent, vulnerabilityList, eventList);
        addCountsToDataSet(eventList);
        return eventList;
    }

    private String findVulnerabilityUrl(final String componentVersionUrl) throws IntegrationException {
        String url = null;
        final ComponentVersionView compVersion = hubResponseService.getItem(componentVersionUrl, ComponentVersionView.class);
        url = metaService.getLinks(compVersion, MetaService.VULNERABILITIES_LINK).get(0);
        return url;
    }

    private List<VulnerabilityView> createVulnerabilityItemList(final String vulnerabilityUrl) throws IntegrationException {
        List<VulnerabilityView> itemList = Collections.emptyList();
        if (!StringUtils.isBlank(vulnerabilityUrl)) {
            itemList = vulnerabilityRequestService.getComponentVersionVulnerabilities(vulnerabilityUrl);
        }
        return itemList;
    }

    @SuppressWarnings("unchecked")
    private void addEventsToList(final NotificationEvent originalEvent, final List<VulnerabilityView> vulnerabilityList, final List<NotificationEvent> eventList) {
        final Map<NotificationCategoryEnum, NotificationEvent> eventMap = new HashMap<>();
        final Set<String> eventVulnIdSet = (Set<String>) originalEvent.getDataSet().get(VULNERABILITY_ID_SET);
        for (final String vulnId : eventVulnIdSet) {
            for (final VulnerabilityView vulnerability : vulnerabilityList) {
                final NotificationCategoryEnum eventCategory = getEventCategory(vulnerability.severity);
                final String vulnName = vulnerability.vulnerabilityName;
                if (vulnId.equals(vulnName)) {
                    if (eventMap.containsKey(eventCategory)) {
                        final NotificationEvent event = eventMap.get(eventCategory);
                        final Set<String> vulnSet = (Set<String>) event.getDataSet().get(VULNERABILITY_ID_SET);
                        vulnSet.add(vulnName);
                    } else {
                        final Set<String> vulnset = new HashSet<>();
                        vulnset.add(vulnName);
                        final Map<String, Object> dataSet = new HashMap<>(originalEvent.getDataSet());
                        dataSet.put(VULNERABILITY_ID_SET, vulnset);
                        final NotificationEvent event = new NotificationEvent(originalEvent.getEventKey(), eventCategory, dataSet);
                        eventMap.put(eventCategory, event);
                        eventList.add(event);
                    }
                }
            }
        }
    }

    private NotificationCategoryEnum getEventCategory(final String severityString) {
        final VulnerabilitySeverityEnum severity = VulnerabilitySeverityEnum.valueOf(severityString.toUpperCase());

        switch (severity) {
        case HIGH: {
            return NotificationCategoryEnum.HIGH_VULNERABILITY;
        }
        case MEDIUM: {
            return NotificationCategoryEnum.MEDIUM_VULNERABILITY;
        }
        case LOW: {
            return NotificationCategoryEnum.LOW_VULNERABILITY;
        }
        default: {
            return NotificationCategoryEnum.VULNERABILITY;
        }
        }
    }

    @SuppressWarnings("unchecked")
    private void addCountsToDataSet(final List<NotificationEvent> eventList) {
        for (final NotificationEvent event : eventList) {
            final Set<String> eventVulnIdSet = (Set<String>) event.getDataSet().get(VULNERABILITY_ID_SET);
            final int size = eventVulnIdSet.size();
            if (size > 1) {
                event.getDataSet().put(ItemTypeEnum.COUNT.name(), new Integer(size));
            }
        }
    }

}

/**
 * blackduck-alert
 *
 * Copyright (C) 2018 Black Duck Software, Inc.
 * http://www.blackducksoftware.com/
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.blackducksoftware.integration.alert.workflow.processor.vulnerability;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import com.blackducksoftware.integration.alert.common.enumeration.VulnerabilityOperation;
import com.blackducksoftware.integration.alert.common.model.NotificationModel;
import com.blackducksoftware.integration.alert.config.GlobalProperties;
import com.blackducksoftware.integration.alert.database.entity.NotificationCategoryEnum;
import com.blackducksoftware.integration.alert.database.entity.NotificationEntity;
import com.blackducksoftware.integration.alert.database.entity.VulnerabilityEntity;
import com.blackducksoftware.integration.alert.workflow.processor.NotificationTypeProcessor;
import com.blackducksoftware.integration.exception.IntegrationException;
import com.blackducksoftware.integration.hub.api.UriSingleResponse;
import com.blackducksoftware.integration.hub.api.generated.enumeration.NotificationType;
import com.blackducksoftware.integration.hub.api.generated.view.ComponentVersionView;
import com.blackducksoftware.integration.hub.api.generated.view.ProjectVersionView;
import com.blackducksoftware.integration.hub.api.generated.view.VulnerabilityV2View;
import com.blackducksoftware.integration.hub.notification.NotificationDetailResult;
import com.blackducksoftware.integration.hub.notification.content.VulnerabilityNotificationContent;
import com.blackducksoftware.integration.hub.notification.content.VulnerabilitySourceQualifiedId;
import com.blackducksoftware.integration.hub.notification.content.detail.NotificationContentDetail;
import com.blackducksoftware.integration.hub.service.HubService;
import com.blackducksoftware.integration.hub.service.HubServicesFactory;
import com.blackducksoftware.integration.hub.service.bucket.HubBucket;
import com.blackducksoftware.integration.hub.service.bucket.HubBucketService;
import com.blackducksoftware.integration.rest.connection.RestConnection;

@Component
public class VulnerabilityNotificationTypeProcessor extends NotificationTypeProcessor {
    private final Logger logger = LoggerFactory.getLogger(VulnerabilityNotificationTypeProcessor.class);

    public VulnerabilityNotificationTypeProcessor() {
        super(new LinkedHashSet<>(Arrays.asList(NotificationType.VULNERABILITY)));
    }

    @Override
    public List<NotificationModel> process(final GlobalProperties globalProperties, final NotificationDetailResult notificationDetailResult, final HubBucket bucket) {

        final List<NotificationContentDetail> detailList = notificationDetailResult.getNotificationContentDetails();
        final List<NotificationModel> modelList = new ArrayList<>(detailList.size());
        final Map<String, VulnerabilityV2View> vulnerabilityViewMap = new HashMap<>(50);
        detailList.forEach(detail -> {
            modelList.addAll(createModelList(globalProperties, bucket, notificationDetailResult, detail, vulnerabilityViewMap));
        });
        return modelList;
    }

    protected List<NotificationModel> createModelList(final GlobalProperties globalProperties, final HubBucket bucket, final NotificationDetailResult notificationDetailResult, final NotificationContentDetail notificationContentDetail,
            final Map<String, VulnerabilityV2View> vulnerabilityViewMap) {

        final List<NotificationModel> modelList = new ArrayList<>(3);
        try (final RestConnection restConnection = globalProperties.createRestConnectionAndLogErrors(logger)) {
            if (restConnection != null) {
                final HubServicesFactory hubServicesFactory = globalProperties.createHubServicesFactory(restConnection);
                final HubService hubService = hubServicesFactory.createHubService();
                final HubBucketService bucketService = hubServicesFactory.createHubBucketService();

                // have 3 notification types we are interested in high, medium, and low
                final Map<NotificationCategoryEnum, VulnerabilityStateTable> vulnerabilityStateTableMap = new HashMap<>(3);
                vulnerabilityStateTableMap.put(NotificationCategoryEnum.HIGH_VULNERABILITY, new VulnerabilityStateTable());
                vulnerabilityStateTableMap.put(NotificationCategoryEnum.MEDIUM_VULNERABILITY, new VulnerabilityStateTable());
                vulnerabilityStateTableMap.put(NotificationCategoryEnum.LOW_VULNERABILITY, new VulnerabilityStateTable());

                final VulnerabilityNotificationContent content = (VulnerabilityNotificationContent) notificationDetailResult.getNotificationContent();
                manageVulnerabiltyViewMap(vulnerabilityViewMap, notificationContentDetail, bucketService, bucket, hubService);
                manageModelVulnerabilityData(vulnerabilityViewMap, content, vulnerabilityStateTableMap);

                final List<VulnerabilityEntity> highVulnList = vulnerabilityStateTableMap.get(NotificationCategoryEnum.HIGH_VULNERABILITY).getVulnerabilityList();
                final List<VulnerabilityEntity> mediumVulnList = vulnerabilityStateTableMap.get(NotificationCategoryEnum.MEDIUM_VULNERABILITY).getVulnerabilityList();
                final List<VulnerabilityEntity> lowVulnList = vulnerabilityStateTableMap.get(NotificationCategoryEnum.LOW_VULNERABILITY).getVulnerabilityList();

                if (!highVulnList.isEmpty()) {
                    final NotificationEntity highEntity = createNotificationEntity(notificationDetailResult, notificationContentDetail, NotificationCategoryEnum.HIGH_VULNERABILITY);
                    modelList.add(new NotificationModel(highEntity, highVulnList));
                }

                if (!mediumVulnList.isEmpty()) {
                    final NotificationEntity mediumEntity = createNotificationEntity(notificationDetailResult, notificationContentDetail, NotificationCategoryEnum.MEDIUM_VULNERABILITY);
                    modelList.add(new NotificationModel(mediumEntity, mediumVulnList));
                }

                if (!lowVulnList.isEmpty()) {
                    final NotificationEntity lowEntity = createNotificationEntity(notificationDetailResult, notificationContentDetail, NotificationCategoryEnum.LOW_VULNERABILITY);
                    modelList.add(new NotificationModel(lowEntity, lowVulnList));
                }
            }

        } catch (final Exception ex) {
            logger.error("Error occurred getting vulnerability data.", ex);
        }
        return modelList;
    }

    private void manageVulnerabiltyViewMap(final Map<String, VulnerabilityV2View> vulnerabilityViewMap, final NotificationContentDetail detail, final HubBucketService bucketService, final HubBucket bucket,
            final HubService hubService)
            throws IntegrationException {
        final Optional<UriSingleResponse<ComponentVersionView>> componentVersion = detail.getComponentVersion();
        if (componentVersion.isPresent()) {
            final String uri = componentVersion.get().uri;
            if (!bucket.contains(uri)) {
                bucketService.addToTheBucket(bucket, Arrays.asList(componentVersion.get()));
            }
            final ComponentVersionView versionView = bucket.get(uri, ComponentVersionView.class);
            final List<VulnerabilityV2View> vulnerabilityList = hubService.getAllResponses(versionView, ComponentVersionView.VULNERABILITIES_LINK_RESPONSE);
            vulnerabilityList.forEach(vulnerability -> {
                if (!vulnerabilityViewMap.containsKey(vulnerability.name)) {
                    vulnerabilityViewMap.put(vulnerability.name, vulnerability);
                    try {
                        bucketService.addToTheBucket(bucket, vulnerability._meta.href, VulnerabilityV2View.class);
                    } catch (final IntegrationException ex) {
                        logger.error("Attempting to add vulnerability {} to bucket failed", ex);
                    }
                }
            });
        }
    }

    private void manageModelVulnerabilityData(final Map<String, VulnerabilityV2View> vulnerabilityViewMap, final VulnerabilityNotificationContent content,
            final Map<NotificationCategoryEnum, VulnerabilityStateTable> vulnerabiltyStateTableMap) {
        if (content.newVulnerabilityCount > 0) {
            content.newVulnerabilityIds.forEach(item -> {
                addToVulnerabilityTable(vulnerabilityViewMap, VulnerabilityOperation.ADD, vulnerabiltyStateTableMap, item);
            });
        }

        if (content.updatedVulnerabilityCount > 0) {
            content.updatedVulnerabilityIds.forEach(item -> {
                addToVulnerabilityTable(vulnerabilityViewMap, VulnerabilityOperation.UPDATE, vulnerabiltyStateTableMap, item);
            });
        }

        if (content.deletedVulnerabilityCount > 0) {
            content.deletedVulnerabilityIds.forEach(item -> {
                addToVulnerabilityTable(vulnerabilityViewMap, VulnerabilityOperation.DELETE, vulnerabiltyStateTableMap, item);
            });
        }
    }

    private void addToVulnerabilityTable(final Map<String, VulnerabilityV2View> vulnerabilityViewMap, final VulnerabilityOperation operation, final Map<NotificationCategoryEnum, VulnerabilityStateTable> vulnerabiltyStateTableMap,
            final VulnerabilitySourceQualifiedId item) {
        if (vulnerabilityViewMap.containsKey(item.vulnerabilityId)) {
            final VulnerabilityV2View vulnerabilityView = vulnerabilityViewMap.get(item.vulnerabilityId);
            final NotificationCategoryEnum notificationType = getNotificationCategory(vulnerabilityView.severity);
            final VulnerabilityStateTable vulnerabilityStateTable = vulnerabiltyStateTableMap.get(notificationType);
            vulnerabilityStateTable.addVulnerabilityData(operation, createEntityFromSourceQualifiedId(item, operation));
        }
    }

    private NotificationCategoryEnum getNotificationCategory(final String severityString) {
        final String severity = severityString.toUpperCase();

        if (severity.equals("HIGH")) {
            return NotificationCategoryEnum.HIGH_VULNERABILITY;
        } else if (severity.equals("MEDIUM")) {
            return NotificationCategoryEnum.MEDIUM_VULNERABILITY;
        } else if (severity.equals("LOW")) {
            return NotificationCategoryEnum.LOW_VULNERABILITY;
        } else {
            return NotificationCategoryEnum.VULNERABILITY;
        }
    }

    private VulnerabilityEntity createEntityFromSourceQualifiedId(final VulnerabilitySourceQualifiedId item, final VulnerabilityOperation operation) {
        return new VulnerabilityEntity(item.vulnerabilityId, operation, null);
    }

    private NotificationEntity createNotificationEntity(final NotificationDetailResult notificationDetailResult, final NotificationContentDetail notificationContentDetail, final NotificationCategoryEnum notificationCategory) {
        final Date createdAt = notificationDetailResult.getCreatedAt();
        final String contentKey = notificationContentDetail.getContentDetailKey();
        final String projectName = notificationContentDetail.getProjectName().orElse(null);
        final String projectUrl = null;
        final String projectVersion = notificationContentDetail.getProjectVersionName().orElse(null);
        String projectVersionUrl = null;
        final Optional<UriSingleResponse<ProjectVersionView>> projectVersionResponse = notificationContentDetail.getProjectVersion();
        final Optional<String> componentNameDetail = notificationContentDetail.getComponentName();
        final Optional<String> componentVersionDetail = notificationContentDetail.getComponentVersionName();
        if (projectVersionResponse.isPresent()) {
            projectVersionUrl = projectVersionResponse.get().uri;
        }
        String componentName = null;
        if (componentNameDetail.isPresent()) {
            componentName = componentNameDetail.get();
        }
        String componentVersion = null;
        if (componentVersionDetail.isPresent()) {
            componentVersion = componentVersionDetail.get();
        }
        final String policyRuleName = null;
        final String policyRuleUser = null;
        return new NotificationEntity(contentKey, createdAt, notificationCategory, projectName, projectUrl, projectVersion, projectVersionUrl, componentName, componentVersion, policyRuleName, policyRuleUser);
    }

}

String dockerStagingDirectory = rootProject.ext.dockerStagingDirectory
String baseDockerDirectory = rootProject.ext.baseDockerDirectory

// Names of non-image specific Docker tasks
String dockerCleanStagingAreaDirectory = rootProject.ext.dockerCleanStagingAreaDirectoryStageName
String dockerRemoveAllImages = rootProject.ext.dockerRemoveAllImagesStageName
String dockerSetupStagingAreaDirectory = rootProject.ext.dockerSetupStagingAreaDirectoryStageName
String dockerBuildAllImages = rootProject.ext.dockerBuildAllImagesStageName
String dockerPublishAllImages_DH = rootProject.ext.dockerPublishAllImages_DHStageName
String dockerPublishAllImages_ART = rootProject.ext.dockerPublishAllImages_ARTStageName
String dockerPublishAllImages = rootProject.ext.dockerPublishAllImagesStageName

ArrayList<String> dockerTasksCreated = []

project.tasks.create(name: dockerCleanStagingAreaDirectory, group: 'Docker', description: 'Remove staging area used for creating Docker images') {
    dockerTasksCreated.add(dockerCleanStagingAreaDirectory)
    doFirst {
        logger.lifecycle('Removing Docker staging area:: ' + dockerStagingDirectory)
    }

    file(dockerStagingDirectory).deleteDir()
}
clean.finalizedBy(project.tasks.findByName(dockerCleanStagingAreaDirectory))

project.tasks.create(name: dockerRemoveAllImages, group: 'Docker', description: 'Remove docker images and staging area for project') {
    dockerTasksCreated.add(dockerRemoveAllImages)
}
clean.finalizedBy(project.tasks.findByName(dockerRemoveAllImages))

project.tasks.create(name: dockerSetupStagingAreaDirectory, type: Copy, group: 'Docker', description: 'Populate staging area used for creating Docker images') {
    dockerTasksCreated.add(dockerSetupStagingAreaDirectory)
    dependsOn project.tasks.findByName(dockerCleanStagingAreaDirectory)

    doFirst {
        logger.lifecycle('Setting up docker staging area')
    }

    into dockerStagingDirectory
    from(baseDockerDirectory)

    into('blackduck-alert') {
        from tarTree("${project.buildDir}/distributions/blackduck-alert-boot-${project.version}.tar")
    }
}

project.tasks.create(name: dockerBuildAllImages, group: 'Docker', description: 'Build docker images for project') {
    dockerTasksCreated.add(dockerBuildAllImages)
    dependsOn project.tasks.findByName(dockerSetupStagingAreaDirectory)
}

project.tasks.create(name: dockerPublishAllImages_DH, group: 'Docker_DH', description: 'Publish docker images for project to hub.docker.com') {
    dockerTasksCreated.add(dockerPublishAllImages_DH)
    dependsOn project.tasks.findByName(dockerBuildAllImages)

    onlyIf(envVarsNotExistMsg) {
        System.env.DOCKER_INT_BLACKDUCK_USER != null && System.env.DOCKER_INT_BLACKDUCK_PASSWORD != null
    }
}

project.tasks.create(name: dockerPublishAllImages_ART, group: 'Docker_Artifactory', description: 'Publish docker images for project to Artifactory') {
    dockerTasksCreated.add(dockerPublishAllImages_ART)
    dependsOn project.tasks.findByName(dockerBuildAllImages)

    onlyIf(envVarsNotExistMsg) {
        System.env.ARTIFACTORY_DEPLOYER_USER != null && System.env.ARTIFACTORY_DEPLOYER_PASSWORD != null && System.env.DOCKER_REGISTRY_SIG != null
    }
}

project.tasks.create(name: dockerPublishAllImages, group: 'Docker', description: 'Publish docker images for project to Artifactory & hub.docker.com') {
    dockerTasksCreated.add(dockerPublishAllImages)
    dependsOn project.tasks.findByName(dockerPublishAllImages_DH), project.tasks.findByName(dockerPublishAllImages_ART)
}

/*
  Each Dockerfile to be built should be in a subdirectory of "${project.projectDir}/${baseDockerDirectory}"
  For each Dockerfile found within 'baseDockerDirectory', gradle tasks will be added
  The subdirectory should be named what the image should be named
  If the image has an ENTRYPOINT script, it should be put in the subdirectory and named docker-entrypoint.sh
*/
ArrayList<String> dockerImagesToBuild = []
new File(baseDockerDirectory).eachFileRecurse() { it ->
    if (it.isFile() && it.name == 'Dockerfile') {
        dockerImagesToBuild.add(it.getParentFile().getName())
    }
}

dockerImagesToBuild.each { imageName ->
    String fullDockerImageName = 'blackducksoftware/' + imageName + ':' + project.version
    String artifactoryDockerImageName = System.env.DOCKER_REGISTRY_SIG + '/' + fullDockerImageName
    logger.lifecycle('Creating tasks to process Docker image:: ' + fullDockerImageName)

    String imageTaskNameSuffix = ''
    for (String token : imageName.split("-")) {
        imageTaskNameSuffix += token.substring(0, 1).toUpperCase() + token.substring(1).toLowerCase()
    }

    String dockerImageRemoveTaskName = "dockerRemove${imageTaskNameSuffix}"
    String dockerImageBuildTaskName = "dockerBuild${imageTaskNameSuffix}"

    project.tasks.create(name: dockerImageRemoveTaskName, type: Exec, group: 'Docker', description: "Remove ${fullDockerImageName} docker image") {
        dockerTasksCreated.add(dockerImageRemoveTaskName)
        outputs.upToDateWhen { false }

        doFirst {
            logger.lifecycle('Removing docker image:: ' + fullDockerImageName)
        }

        ignoreExitValue = true
        errorOutput = new ByteArrayOutputStream()

        commandLine 'docker', 'image', 'rm', fullDockerImageName

        doLast {
            String stdErr = errorOutput.toString()

            if (stdErr?.trim() && !stdErr.contains("Deleted: ")) {
                if (stdErr.contains("Error: No such image")) {
                    logger.lifecycle("Image does not exist, continuing.")
                } else {
                    throw new GradleException("${stdErr}")
                }
            }
        }
    }
    project.tasks.findByName(dockerRemoveAllImages).dependsOn dockerImageRemoveTaskName

    project.tasks.create(name: dockerImageBuildTaskName, type: Exec, group: 'Docker', description: "Build ${imageName} docker image") {
        dockerTasksCreated.add(dockerImageBuildTaskName)
        outputs.upToDateWhen { false }
        dependsOn project.tasks.findByName(dockerSetupStagingAreaDirectory)

        def buildCommand = ['docker', 'build', '.', '-t', fullDockerImageName, '--pull', '--force-rm', '--build-arg', "VERSION=${project.version}"]
        rootProject.ext.properties.each { key, value ->
            if (key.startsWith('dockerBuildParam_')) {
                String adjKey = key.substring(key.indexOf('_') + 1)
                buildCommand.add('--build-arg')
                buildCommand.add("${adjKey}=${value}")
            }
        }

        doFirst {
            logger.lifecycle("Building docker image:: ${fullDockerImageName}")
            logger.lifecycle('Running command:: ' + buildCommand.join(" "))
        }

        workingDir "${dockerStagingDirectory}/${imageName}"
        commandLine buildCommand
    }
    project.tasks.findByName(dockerBuildAllImages).dependsOn dockerImageBuildTaskName

    // Docker Hub specific tasks
    String dockerImageLoginDHTaskName = "dockerLogin${imageTaskNameSuffix}_DH"
    String dockerImagePublishDHTaskName = "dockerPublish${imageTaskNameSuffix}_DH"

    project.tasks.create(name: dockerImageLoginDHTaskName, type: Exec, group: 'Docker_DH', description: 'Docker login to hub.docker.com') {
        dockerTasksCreated.add(dockerImageLoginDHTaskName)
        outputs.upToDateWhen { false }

        String dockerLoginUsername = System.env.DOCKER_INT_BLACKDUCK_USER ?: '<Not Set>'
        doFirst {
            String dockerLoginPassword = System.env.DOCKER_INT_BLACKDUCK_PASSWORD
            if (dockerLoginPassword?.trim()) {
                standardInput = new ByteArrayInputStream(dockerLoginPassword.getBytes())
            }
        }

        commandLine 'docker', 'login', '--username', dockerLoginUsername, '--password-stdin'

        onlyIf(envVarsNotExistMsg) {
            System.env.DOCKER_INT_BLACKDUCK_USER != null && System.env.DOCKER_INT_BLACKDUCK_PASSWORD != null
        }
    }

    project.tasks.create(name: dockerImagePublishDHTaskName, type: Exec, group: 'Docker_DH', description: "Docker push ${imageName} to hub.docker.com") {
        dockerTasksCreated.add(dockerImagePublishDHTaskName)
        outputs.upToDateWhen { false }
        dependsOn project.tasks.findByName(dockerImageLoginDHTaskName)
        commandLine 'docker', 'version'
        //commandLine 'docker', 'push', fullDockerImageName

        onlyIf(envVarsNotExistMsg) {
            project.ext.isRelease
        }
    }
    project.tasks.findByName(dockerPublishAllImages_DH).dependsOn dockerImagePublishDHTaskName

    // Artifactory specific tasks
    String dockerImageTagARTaskName = "dockerTag${imageTaskNameSuffix}_ART"
    String dockerImageLoginARTTaskName = "dockerLogin${imageTaskNameSuffix}_ART"
    String dockerImagePublishARTTaskName = "dockerPublish${imageTaskNameSuffix}_ART"
    String dockerImageRemoveTagARTaskName = "dockerRemoveTag${imageTaskNameSuffix}_ART"

    project.tasks.create(name: dockerImageTagARTaskName, type: Exec, group: 'Docker_Artifactory', description: "Docker tag ${imageName} for push to Artifactory") {
        dockerTasksCreated.add(dockerImageTagARTaskName)
        outputs.upToDateWhen { false }
        commandLine 'docker', 'tag', fullDockerImageName, artifactoryDockerImageName

        onlyIf(envVarsNotExistMsg) {
            System.env.DOCKER_REGISTRY_SIG != null
        }
    }

    project.tasks.create(name: dockerImageLoginARTTaskName, type: Exec, group: 'Docker_Artifactory', description: 'Docker login to Artifactory') {
        dockerTasksCreated.add(dockerImageLoginARTTaskName)
        outputs.upToDateWhen { false }

        String dockerLoginUsername = System.env.ARTIFACTORY_DEPLOYER_USER ?: '<Not Set>'
        doFirst {
            String dockerLoginPassword = System.env.ARTIFACTORY_DEPLOYER_PASSWORD
            if (dockerLoginPassword?.trim()) {
                standardInput = new ByteArrayInputStream(dockerLoginPassword.getBytes())
            }
        }

        commandLine 'docker', 'login', '--username', dockerLoginUsername, '--password-stdin', "${System.env.DOCKER_REGISTRY_SIG}"

        onlyIf(envVarsNotExistMsg) {
            System.env.ARTIFACTORY_DEPLOYER_USER != null && System.env.ARTIFACTORY_DEPLOYER_PASSWORD != null && System.env.DOCKER_REGISTRY_SIG != null
        }
    }

    project.tasks.create(name: dockerImagePublishARTTaskName, type: Exec, group: 'Docker_Artifactory', description: "Docker push ${artifactoryDockerImageName} to Artifactory") {
        dockerTasksCreated.add(dockerImagePublishARTTaskName)
        outputs.upToDateWhen { false }
        dependsOn project.tasks.findByName(dockerImageLoginARTTaskName)
        commandLine 'docker', 'version'
        //commandLine 'docker' , 'push' , artifactoryDockerImageName

        onlyIf(envVarsNotExistMsg) {
            System.env.DOCKER_REGISTRY_SIG != null
        }
    }

    project.tasks.create(name: dockerImageRemoveTagARTaskName, type: Exec, group: 'Docker_Artifactory', description: "Docker remove ${artifactoryDockerImageName}") {
        dockerTasksCreated.add(dockerImageRemoveTagARTaskName)
        outputs.upToDateWhen { false }
        dependsOn project.tasks.findByName(dockerImagePublishARTTaskName)
        commandLine 'docker', 'image', 'rm', artifactoryDockerImageName

        onlyIf(envVarsNotExistMsg) {
            System.env.DOCKER_REGISTRY_SIG != null
        }
    }
    project.tasks.findByName(dockerPublishAllImages_ART).dependsOn dockerImageRemoveTagARTaskName
}

logger.lifecycle('\nThe following Docker specific tasks were added --> ' + dockerTasksCreated)
